from .parser_helpers import *

# Code @generated by parsergen; do not edit!
from parsergen.parser_utils import GeneratedParser, TokenStream, Node, Filler
from parsergen.parser_utils import memoize, memoize_left_rec
from functools import reduce

class CustomParser(GeneratedParser):
    @memoize
    def program(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('EOF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            p = parts[0]
            return Module(body=p, type_ignores=[], **self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def compound(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._loop_0()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            c = parts[0]
            return PyECP_Compound(c, self.loc)
        self.goto(pos)
        
        return None
        
    def _loop_0(self):
        children = []
        while True:
            pos = self.mark()
            part = self.statement()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    @memoize
    def statement(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_1()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return PyECP_ExprStatement(e)
        self.goto(pos)
        
        return None
        
    def _or_1(self):
        pos = self.mark()
        part = self.if_statement()
        if self.match(part): return part
        self.goto(pos)
        part = self.for_loop()
        if self.match(part): return part
        self.goto(pos)
        part = self.while_loop()
        if self.match(part): return part
        self.goto(pos)
        part = self.repeat_until_loop()
        if self.match(part): return part
        self.goto(pos)
        part = self.record_definition()
        if self.match(part): return part
        self.goto(pos)
        part = self.try_catch()
        if self.match(part): return part
        self.goto(pos)
        part = self.suboroutine_definition()
        if self.match(part): return part
        self.goto(pos)
        part = self.class_definition()
        if self.match(part): return part
        self.goto(pos)
        part = self.import_statement()
        if self.match(part): return part
        self.goto(pos)
        part = self.assignment_statement()
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize
    def assignment_statement(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.variable()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_2()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ASSIGN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            target = parts[0]
            value = parts[3]
            return PyECP_Assign(target, value, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_2(self):
        pos = self.mark()
        part = self._expr_list_3()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_3(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COLON')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize
    def variable(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._maybe_4()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.indexing()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            name = parts[1]
            indexing = parts[2]
            return PyECP_Variable(name, indexing, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_4(self):
        pos = self.mark()
        part = self.expect('CONSTANT')
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    @memoize
    def parameters(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._maybe_5()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            params = parts[0]
            return PyECP_Parameters(params)
        self.goto(pos)
        
        return None
        
    def _maybe_5(self):
        pos = self.mark()
        part = self._expr_list_6()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_6(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_7()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_8()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _loop_7(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_9()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _expr_list_9(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COMMA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _maybe_8(self):
        pos = self.mark()
        part = self.expect('COMMA')
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    @memoize
    def attr_index(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('DOT')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[1]
            return "attr", i.value
        self.goto(pos)
        
        return None
        
    @memoize
    def subscript_index(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('LS_PAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RS_PAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            i = parts[1]
            return "subscript", i
        self.goto(pos)
        
        return None
        
    @memoize
    def call(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('LPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.parameters()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            params = parts[1]
            return "call", params
        self.goto(pos)
        
        return None
        
    @memoize
    def indexing(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._loop_10()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            indexes = parts[0]
            return [i for [i] in indexes]
        self.goto(pos)
        
        return None
        
    def _loop_10(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_11()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _expr_list_11(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_12()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _or_12(self):
        pos = self.mark()
        part = self.attr_index()
        if self.match(part): return part
        self.goto(pos)
        part = self.subscript_index()
        if self.match(part): return part
        self.goto(pos)
        part = self.call()
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize_left_rec
    def factor(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.factor_part()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.indexing()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            f = parts[0]
            i = parts[1]
            return PyECP_Factor(f, i, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize_left_rec
    def factor_part(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_13()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            t = parts[0]
            return PyECP_Constant(t, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.expect('LPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[1]
            return e
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self._or_14()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            p = parts[0]
            return p
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self._or_15()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.factor()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            op = parts[0]
            e = parts[1]
            return PyECP_UnaryOp(op, e)
        self.goto(pos)
        
        return None
        
    def _or_13(self):
        pos = self.mark()
        part = self.expect('INT')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('FLOAT')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('BOOLEAN')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('STRING')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('NONE')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    def _or_14(self):
        pos = self.mark()
        part = self.array()
        if self.match(part): return part
        self.goto(pos)
        part = self.dictionary()
        if self.match(part): return part
        self.goto(pos)
        part = self.tuple()
        if self.match(part): return part
        self.goto(pos)
        part = self.magic_function()
        if self.match(part): return part
        self.goto(pos)
        part = self.variable()
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    def _or_15(self):
        pos = self.mark()
        part = self.expect('PLUS')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('SUB')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('NOT')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize_left_rec
    def expr(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.op_or()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    @memoize_left_rec
    def op_or(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.op_and()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_16()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            base = parts[0]
            others = parts[1]
            return PyECP_BoolOp(base, "OR", others, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.op_and()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    def _loop_16(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_17()
            if self.match(part): children.append(part)
            else:
                if len(children) == 0:
                    self.fail()
                self.goto(pos)
                break
        return children if len(children) > 0 else None
    def _expr_list_17(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('OR')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.op_and()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize_left_rec
    def op_and(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.inversion()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_18()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            base = parts[0]
            others = parts[1]
            return PyECP_BoolOp(base, "AND", others, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.inversion()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    def _loop_18(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_19()
            if self.match(part): children.append(part)
            else:
                if len(children) == 0:
                    self.fail()
                self.goto(pos)
                break
        return children if len(children) > 0 else None
    def _expr_list_19(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('AND')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.inversion()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize_left_rec
    def inversion(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('NOT')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.inversion()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            op = parts[0]
            e = parts[1]
            return PyECP_UnaryOp(op, e)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.comparison()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    @memoize_left_rec
    def comparison(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.sum()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_20()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            base = parts[0]
            others = parts[1]
            return PyECP_Comparison(base, others, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.sum()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    def _loop_20(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_21()
            if self.match(part): children.append(part)
            else:
                if len(children) == 0:
                    self.fail()
                self.goto(pos)
                break
        return children if len(children) > 0 else None
    def _expr_list_21(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_22()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.sum()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _or_22(self):
        pos = self.mark()
        part = self.expect('LT')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('GT')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('LE')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('GE')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('EQ')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('NE')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize_left_rec
    def sum(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.sum()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._or_23()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.term()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            left = parts[0]
            op = parts[1]
            right = parts[2]
            return PyECP_BinOp(left, right, op, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.term()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    def _or_23(self):
        pos = self.mark()
        part = self.expect('ADD')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('SUB')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize_left_rec
    def term(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.term()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._or_24()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.uop()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            left = parts[0]
            op = parts[1]
            right = parts[2]
            return PyECP_BinOp(left, right, op, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.uop()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    def _or_24(self):
        pos = self.mark()
        part = self.expect('MUL')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('DIV')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('INT_DIV')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('MOD')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize_left_rec
    def uop(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_25()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.uop()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            op = parts[0]
            e = parts[1]
            return PyECP_UnaryOp(op, e)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.power()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    def _or_25(self):
        pos = self.mark()
        part = self.expect('ADD')
        if self.match(part): return part
        self.goto(pos)
        part = self.expect('SUB')
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize_left_rec
    def power(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.power()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('POW')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.factor()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            left = parts[0]
            op = parts[1]
            right = parts[2]
            return PyECP_BinOp(left, right, op, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.factor()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            e = parts[0]
            return e
        self.goto(pos)
        
        return None
        
    @memoize
    def magic_function(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('MAGIC')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.parameters()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            name = parts[0]
            parameters = parts[1]
            return PyECP_Magic(name.value, parameters, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def param_definition(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_26()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            name = parts[0]
            return arg(arg=name.value, annotation=None, **self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_26(self):
        pos = self.mark()
        part = self._expr_list_27()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_27(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COLON')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize
    def suboroutine_definition(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('SUBROUTINE')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('LPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_28()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            name = parts[1]
            params = parts[3]
            block = parts[5]
            return PyECP_SubroutineDef(name, params, block, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_28(self):
        pos = self.mark()
        part = self._expr_list_29()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_29(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.param_definition()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_30()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_31()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _loop_30(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_32()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _expr_list_32(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COMMA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.param_definition()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _maybe_31(self):
        pos = self.mark()
        part = self.expect('COMMA')
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    @memoize
    def if_statement(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('IF')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('THEN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_33()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            condition = parts[1]
            block = parts[3]
            other = parts[4]
            return PyECP_IfStatement(condition, block, other, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_33(self):
        pos = self.mark()
        part = self._expr_list_34()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_34(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self._or_35()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _or_35(self):
        pos = self.mark()
        part = self.elseif_statement()
        if self.match(part): return part
        self.goto(pos)
        part = self.else_statement()
        if self.match(part): return part
        self.goto(pos)
        self.fail()
        return None
    @memoize
    def elseif_statement(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('ELSE')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.if_statement()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            otherwise = parts[1]
            return [otherwise]
        self.goto(pos)
        
        return None
        
    @memoize
    def else_statement(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('ELSE')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            block = parts[1]
            return block
        self.goto(pos)
        
        return None
        
    @memoize
    def while_loop(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('WHILE')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            condition = parts[1]
            block = parts[2]
            return PyECP_While(condition, block, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def repeat_until_loop(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('REPEAT')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('UNTIL')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            block = parts[1]
            condition = parts[3]
            return PyECP_RepeatUntil(condition, block, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def array(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('LS_PAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.parameters()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RS_PAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            values = parts[1]
            return PyECP_Array(values, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def tuple(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('LPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.parameters()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RPAREN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            values = parts[1]
            return PyECP_Tuple(values, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def dictionary(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('LC_BRACE')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_36()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('RC_BRACE')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            kv_pairs = parts[1]
            return PyECP_Dictionary(kv_pairs, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_36(self):
        pos = self.mark()
        part = self._expr_list_37()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_37(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('COLON')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_38()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_39()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _loop_38(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_40()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _expr_list_40(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COMMA')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('COLON')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _maybe_39(self):
        pos = self.mark()
        part = self.expect('COMMA')
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    @memoize
    def for_loop(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('FOR')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.variable()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ASSIGN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('TO')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_41()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            v = parts[1]
            start = parts[3]
            end = parts[5]
            step = parts[6]
            block = parts[7]
            return PyECP_ForTo(v, start, end, step, block, self.loc)
        self.goto(pos)
        
        parts = []
        for _ in range(1):
            part = self.expect('FOR')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.variable()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('IN')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            v = parts[1]
            iterator = parts[3]
            block = parts[4]
            return PyECP_ForIn(v, iterator, block, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_41(self):
        pos = self.mark()
        part = self._expr_list_42()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_42(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('STEP')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize
    def record_definition(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('RECORD')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._loop_43()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            name = parts[1]
            values = parts[2]
            return PyECP_Record(name, values, self.loc)
        self.goto(pos)
        
        return None
        
    def _loop_43(self):
        children = []
        while True:
            pos = self.mark()
            part = self._expr_list_44()
            if self.match(part): children.append(part)
            else:
                self.goto(pos)
                break
        return children
    def _expr_list_44(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.variable()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_45()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    def _maybe_45(self):
        pos = self.mark()
        part = self._expr_list_46()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_46(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('COLON')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('ID')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
    @memoize
    def try_catch(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('TRY')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('CATCH')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            try_block = parts[1]
            catch_block = parts[3]
            return PyECP_Try(try_block, catch_block, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def class_definition(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('CLASS')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.variable()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.compound()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expect('END')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            name = parts[1]
            body = parts[2]
            return PyECP_Class(name, body, self.loc)
        self.goto(pos)
        
        return None
        
    @memoize
    def import_statement(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('IMPORT')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self._maybe_47()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            # match:
            location = parts[1]
            target = parts[2]
            return PyECP_Import(location, target, self.loc)
        self.goto(pos)
        
        return None
        
    def _maybe_47(self):
        pos = self.mark()
        part = self._expr_list_48()
        if self.match(part): return part
        self.goto(pos)
        return Filler()
    def _expr_list_48(self):
        pos = self.mark()
        parts = []
        for _ in range(1):
            part = self.expect('AS')
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            part = self.expr()
            if not self.match(part):
                self.fail()
                break
            parts.append(part)
            return parts
        self.goto(pos)
        return None
